# C++

1. 入口　　main函数，与文件名无关，多个main会报错，java可以有多个入口

2. 完全兼容c

3. C++中常使用cin、cout进行控制台的输入、输出，

    cin用的右移运算符>>，cout用的是左移运算符<<

    endl是换行的意思




### 基本语法

1. **函数重载(Overload)**

   1. 函数名相同

   2. 参数个数不同、参数类型不同、参数顺序不同

   3. 返回值类型与函数重载无关

   4. 调用函数时，实参的隐式类型转换可能会产生二义性

   5. **本质**　采用了name mangling或者叫name decoration技术
      1. C++编译器默认会对符号名(变量名、函数名等)进行改编、修饰，有些地方翻译为“命名倾轧”
      2. 重载时会生成多个不同的函数名，不同编译器(MSVC、g++)有不同的生成规则
      3. 通过IDA打开【VS_Release_禁止优化】可以看到
      4. eg: 

2. **extern “C”**

   1. 被extern "C"修饰的代码会按照C语言的方式去编译

   2. 如果函数同时有声明和实现，要让函数声明被extern "C"修饰，函数实现可以不修饰

   3.  由于C、C++编译规则的不同，在C、C++混合开发时，可能会经常出现以下操作,C++在调用C语言API时，需要使用extern "C"修饰C语言的函数声明. **在c++中声明函数，在c文件中写实现，会按c++ name mangling方式找函数实现，然后报错**。需要**extern "C"**

      ``` 
      extern "C" {
      	#include "sum.h"
      }
      ```

      

   4. 有时也会在编写C语言代码中直接使用extern “C” ，这样就可以直接被C++调用,通过使用**__cplusplus**来区分C、C++环境

3. **默认参数**

4.  C++允许函数设置默认参数，在调用时可以根据情况省略实参。规则如下:
   默认参数只能按照**右到左**的顺序.与**swift**不同，swift有标签，因为**二义性**
   如果函数同时有声明、实现，默认参数只能放在函数声明中，
   默认参数的值可以是常量、全局符号(全局变量、函数名），**参数如果是函数，使用的是指向函数的指针**  

### 内联函数

1. 使用**inline**修饰函数的声明或实现，可以使其变成内联函数
2. 建议声明和实现都加上**inline**
3. 特点

   1. 编译器会将函数直接展开为函数体代码
   2. 减少函数调用开销
   3. 会增大代码体积
4. 尽量不要内联超过10行代码的函数
5. 有些函数即使声明为**inline**也不一定会被编译器内联，如递归函数
6. **与宏的区别**

   1. 内联函数和宏都能减少函数调用开销
   2. 内联函数多了函数特性和语法检测
   3. 传入a++调用不一样

### 文件相关宏

1. 我们经常使用#ifndef、#define、#endif来防止头文件的内容被重复包含
2. 使用#pragma once可以防止整个文件的内容被重复包含
3. 使用#ifndef、#define、#endif受C\C++标准的支持，不受编译器的任何限制
4. 有些编译器不支持#pragma once(较老编译器不支持，如GCC 3.4版本之前)，兼容性不够好
5. 使用#ifndef、#define、#endif可以针对一个文件中的部分代码，而#pragma once只能针对整个文件

### 引用 

1. 在C语言中，使用指针(Pointer)可以间接获取、修改某个变量的值

2. 在C++中，使用引用(Reference)可以起到跟指针类似的功能

   ```
   int age = 20;
   int &rAge = age; //rAge就是一个引用 
   ```

3. 引用相当于是变量的别名(基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用)

    ```
   //指针的引用 
   int a = 10;
   int b = 20;
   int *p = &a;
   int *&rp = p;
   rp = &b;
   *p = 30;
   a:10 b:30 
   //数组的引用 
   int array[] = {10,20,30};
   int (&rArray)[3] = array;// int &rArray[3]看起来像引用数组,数组中放3个引用不存在
   
   int *a[3] 指针数组，[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素
   int (*a)[3]//该语句是定义一个数组指针，指向含3个元素的一维数组。
   
   函数返回值可以赋值
   int &func() {
       int a = 10;//a是全局变量才有价值
       return a;
   }
   func() = 30
   
   引用交换a和b的值
   
   ```

   对引用做计算，就是对引用所指向的变量做计算
   在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”
   可以利用引用初始化另一个引用，相当于某个变量的多个别名
   不存在【引用的引用、指向引用的指针、引用数组】

4. 引用存在的价值之一:比指针更安全、函数返回值可以被赋值

5. **引用的本质就是指针，只是编译器削弱了它的功能，所以引用就是弱化了的指针**

6. 一个引用占用一个指针的大小

#### const

1. 是常量的意思，被其修饰的变量不可修改

2. 如果修饰的是类、结构体(的指针)，其成员也不可以更改

   ```
   int a = 10;
   const int *p = &a;// *p不可以改   
   int const *p1 = &a;// *p1不可以改
   int * const p2 = &a;// p2不可以改
   const int * const p3 = &a; // p3与*p3不可以改
   int const * const p4 = &a; // p4与*p4不可以改
   
   const 修饰的是右边的东西，如果右边带*,则*p是常量，不可以改
   
   const Student *pStu = &stu;
   下面两句报错，const 修饰*pStu 表明pStu所指向的内存是常量，不能修改
   (*pStu).age = 30; 
   pStu->age = 40;
   ```

#### 常引用

1. 引用可以被const修饰，这样就无法通过引用修改数据了，可以称为常引用
2. const必须写在&符号的左边，才能算是常引用

```
int age = 10;
int & const rAge = &age; //const 表明rAge的指向不能改，加不加一个意思 
rAge = 20;通过
int const &rAge2 = &age; // rAge不
rAge2 = 30;报错

```

1. 用法  `const int &rAge = 50;  ` `const int &rAge = a + b`

2. 可以指向临时数据(常量、表达式、函数返回值等)
   可以指向不同类型的数据
   **作为函数参数时(此规则也适用于const指针)**
   ✓ 可以接受const和非const实参(非const引用，只能接受非const实参)
   ✓ 可以跟非const引用构成重载,不是引用加const不会构成重载

   ```
   int sum(const int &a,const int &b) {
       retun a + b;
   }
   ```

3.  指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量

#### **数组的引用** 

```
int array[] = {10,20,30}
int (&rArray)[3] = array;
int * const &rArray2 = array;
```



#### 指针汇编 与引用的汇编一样

<figure class="half">
    <img src="./1.png" /><img src="./2.png"/>
</figure>




### 面向对象

#### 类

1. C++中可以使用struct、class来定义一个类

2. struct和class的区别
   **struct**的默认成员权限是**public**    
   **class**的默认成员权限是**private**

   实际开发中，用class表示类比较多

3. 

#### ◼ 变量名规范参考

1. 全局变量:g_
2. 成员变量:m_
3. 静态变量:s_
4. 常量:c_
5. 使用驼峰标识

#### **对象的内存布局**

如果类中有多个成员变量，对象的内存又是如何布局的?

内存对齐、连续，对象地址是首个成员变量的地址

#### **指针访问对象成员的本质**

